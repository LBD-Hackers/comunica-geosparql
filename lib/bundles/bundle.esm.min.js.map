{"version":3,"file":"bundle.esm.min.js","sources":["../../node_modules/rdf-data-factory/lib/BlankNode.js","../../node_modules/rdf-data-factory/lib/DefaultGraph.js","../../node_modules/rdf-data-factory/lib/NamedNode.js","../../node_modules/rdf-data-factory/lib/Literal.js","../../node_modules/rdf-data-factory/lib/Quad.js","../../node_modules/rdf-data-factory/lib/Variable.js","../../node_modules/rdf-data-factory/lib/DataFactory.js","../../node_modules/rdf-data-factory/index.js","../../src/wkt-parser.ts","../../node_modules/point-in-polygon/index.js","../../node_modules/point-in-polygon/flat.js","../../node_modules/point-in-polygon/nested.js","../../src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlankNode = void 0;\n/**\n * A term that represents an RDF blank node with a label.\n */\nclass BlankNode {\n    constructor(value) {\n        this.termType = 'BlankNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'BlankNode' && other.value === this.value;\n    }\n}\nexports.BlankNode = BlankNode;\n//# sourceMappingURL=BlankNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultGraph = void 0;\n/**\n * A singleton term instance that represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass DefaultGraph {\n    constructor() {\n        this.termType = 'DefaultGraph';\n        this.value = '';\n        // Private constructor\n    }\n    equals(other) {\n        return !!other && other.termType === 'DefaultGraph';\n    }\n}\nexports.DefaultGraph = DefaultGraph;\nDefaultGraph.INSTANCE = new DefaultGraph();\n//# sourceMappingURL=DefaultGraph.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NamedNode = void 0;\n/**\n * A term that contains an IRI.\n */\nclass NamedNode {\n    constructor(value) {\n        this.termType = 'NamedNode';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'NamedNode' && other.value === this.value;\n    }\n}\nexports.NamedNode = NamedNode;\n//# sourceMappingURL=NamedNode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Literal = void 0;\nconst NamedNode_1 = require(\"./NamedNode\");\n/**\n * A term that represents an RDF literal, containing a string with an optional language tag or datatype.\n */\nclass Literal {\n    constructor(value, languageOrDatatype) {\n        this.termType = 'Literal';\n        this.value = value;\n        if (typeof languageOrDatatype === 'string') {\n            this.language = languageOrDatatype;\n            this.datatype = Literal.RDF_LANGUAGE_STRING;\n        }\n        else if (languageOrDatatype) {\n            this.language = '';\n            this.datatype = languageOrDatatype;\n        }\n        else {\n            this.language = '';\n            this.datatype = Literal.XSD_STRING;\n        }\n    }\n    equals(other) {\n        return !!other && other.termType === 'Literal' && other.value === this.value &&\n            other.language === this.language && other.datatype.equals(this.datatype);\n    }\n}\nexports.Literal = Literal;\nLiteral.RDF_LANGUAGE_STRING = new NamedNode_1.NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');\nLiteral.XSD_STRING = new NamedNode_1.NamedNode('http://www.w3.org/2001/XMLSchema#string');\n//# sourceMappingURL=Literal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quad = void 0;\n/**\n * An instance of DefaultGraph represents the default graph.\n * It's only allowed to assign a DefaultGraph to the .graph property of a Quad.\n */\nclass Quad {\n    constructor(subject, predicate, object, graph) {\n        this.termType = 'Quad';\n        this.value = '';\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n    }\n    equals(other) {\n        // `|| !other.termType` is for backwards-compatibility with old factories without RDF* support.\n        return !!other && (other.termType === 'Quad' || !other.termType) &&\n            this.subject.equals(other.subject) &&\n            this.predicate.equals(other.predicate) &&\n            this.object.equals(other.object) &&\n            this.graph.equals(other.graph);\n    }\n}\nexports.Quad = Quad;\n//# sourceMappingURL=Quad.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Variable = void 0;\n/**\n * A term that represents a variable.\n */\nclass Variable {\n    constructor(value) {\n        this.termType = 'Variable';\n        this.value = value;\n    }\n    equals(other) {\n        return !!other && other.termType === 'Variable' && other.value === this.value;\n    }\n}\nexports.Variable = Variable;\n//# sourceMappingURL=Variable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataFactory = void 0;\nconst BlankNode_1 = require(\"./BlankNode\");\nconst DefaultGraph_1 = require(\"./DefaultGraph\");\nconst Literal_1 = require(\"./Literal\");\nconst NamedNode_1 = require(\"./NamedNode\");\nconst Quad_1 = require(\"./Quad\");\nconst Variable_1 = require(\"./Variable\");\nlet dataFactoryCounter = 0;\n/**\n * A factory for instantiating RDF terms and quads.\n */\nclass DataFactory {\n    constructor(options) {\n        this.blankNodeCounter = 0;\n        options = options || {};\n        this.blankNodePrefix = options.blankNodePrefix || `df_${dataFactoryCounter++}_`;\n    }\n    /**\n     * @param value The IRI for the named node.\n     * @return A new instance of NamedNode.\n     * @see NamedNode\n     */\n    namedNode(value) {\n        return new NamedNode_1.NamedNode(value);\n    }\n    /**\n     * @param value The optional blank node identifier.\n     * @return A new instance of BlankNode.\n     *         If the `value` parameter is undefined a new identifier\n     *         for the blank node is generated for each call.\n     * @see BlankNode\n     */\n    blankNode(value) {\n        return new BlankNode_1.BlankNode(value || `${this.blankNodePrefix}${this.blankNodeCounter++}`);\n    }\n    /**\n     * @param value              The literal value.\n     * @param languageOrDatatype The optional language or datatype.\n     *                           If `languageOrDatatype` is a NamedNode,\n     *                           then it is used for the value of `NamedNode.datatype`.\n     *                           Otherwise `languageOrDatatype` is used for the value\n     *                           of `NamedNode.language`.\n     * @return A new instance of Literal.\n     * @see Literal\n     */\n    literal(value, languageOrDatatype) {\n        return new Literal_1.Literal(value, languageOrDatatype);\n    }\n    /**\n     * This method is optional.\n     * @param value The variable name\n     * @return A new instance of Variable.\n     * @see Variable\n     */\n    variable(value) {\n        return new Variable_1.Variable(value);\n    }\n    /**\n     * @return An instance of DefaultGraph.\n     */\n    defaultGraph() {\n        return DefaultGraph_1.DefaultGraph.INSTANCE;\n    }\n    /**\n     * @param subject   The quad subject term.\n     * @param predicate The quad predicate term.\n     * @param object    The quad object term.\n     * @param graph     The quad graph term.\n     * @return A new instance of Quad.\n     * @see Quad\n     */\n    quad(subject, predicate, object, graph) {\n        return new Quad_1.Quad(subject, predicate, object, graph || this.defaultGraph());\n    }\n    /**\n     * Create a deep copy of the given term using this data factory.\n     * @param original An RDF term.\n     * @return A deep copy of the given term.\n     */\n    fromTerm(original) {\n        // TODO: remove nasty any casts when this TS bug has been fixed:\n        //  https://github.com/microsoft/TypeScript/issues/26933\n        switch (original.termType) {\n            case 'NamedNode':\n                return this.namedNode(original.value);\n            case 'BlankNode':\n                return this.blankNode(original.value);\n            case 'Literal':\n                if (original.language) {\n                    return this.literal(original.value, original.language);\n                }\n                if (!original.datatype.equals(Literal_1.Literal.XSD_STRING)) {\n                    return this.literal(original.value, this.fromTerm(original.datatype));\n                }\n                return this.literal(original.value);\n            case 'Variable':\n                return this.variable(original.value);\n            case 'DefaultGraph':\n                return this.defaultGraph();\n            case 'Quad':\n                return this.quad(this.fromTerm(original.subject), this.fromTerm(original.predicate), this.fromTerm(original.object), this.fromTerm(original.graph));\n        }\n    }\n    /**\n     * Create a deep copy of the given quad using this data factory.\n     * @param original An RDF quad.\n     * @return A deep copy of the given quad.\n     */\n    fromQuad(original) {\n        return this.fromTerm(original);\n    }\n    /**\n     * Reset the internal blank node counter.\n     */\n    resetBlankNodeCounter() {\n        this.blankNodeCounter = 0;\n    }\n}\nexports.DataFactory = DataFactory;\n//# sourceMappingURL=DataFactory.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/BlankNode\"), exports);\n__exportStar(require(\"./lib/DataFactory\"), exports);\n__exportStar(require(\"./lib/DefaultGraph\"), exports);\n__exportStar(require(\"./lib/Literal\"), exports);\n__exportStar(require(\"./lib/NamedNode\"), exports);\n__exportStar(require(\"./lib/Quad\"), exports);\n__exportStar(require(\"./lib/Variable\"), exports);\n//# sourceMappingURL=index.js.map","export interface WKTGeometry{\n    type: geometryType,\n    value: any\n}\n\nexport enum geometryType{\n    POINT=\"point\",\n    POINTZ=\"pointz\",\n    POLYGON=\"polygon\",\n    POLYGONZ=\"polygonz\",\n    UNKNOWN=\"unknown\"\n}\n\nexport const typeMap = {\n    \"point\": geometryType.POINT,\n    \"pointz\": geometryType.POINTZ,\n    \"polygon\": geometryType.POLYGON,\n    \"polygonz\": geometryType.POLYGONZ\n}\n\nexport function parseWKT(wktString: string): WKTGeometry|null{\n\n    const type = getType(wktString);\n\n    if(type == geometryType.POINT || type == geometryType.POINTZ){\n        const coordinates = parsePoint(wktString);\n        return {value: coordinates, type}\n    }\n\n    if(type == geometryType.POLYGON){\n        const coordinates = parsePolygon(wktString);\n        return {value: coordinates, type}\n    }\n\n}\n\nfunction getType(wktString: string): geometryType{\n\n    wktString = wktString.toLocaleLowerCase();\n\n    let typeStr: string = wktString.split(\"(\")[0];  // get everything before the paranthesis\n    typeStr = typeStr.replace(/\\s+/, \"\");           // remove all white spaces\n    \n    if(Object.keys(typeMap).indexOf(typeStr) != -1){\n        return typeMap[typeStr];\n    }\n\n    return geometryType.UNKNOWN;\n}\n\nfunction parsePolygon(wktString: string): number[]{\n\n    let polygon = [];\n\n    // How many parantheses?\n    const count = wktString.split(\"(\").length;\n    \n    // Non-donut polygon\n    if(count == 2){\n        const points = wktString.split(\"(\")[1].split(\")\")[0].trim();  // Ex [\"0 0 0\"]\n        points.split(\",\").map(point => {\n            point = point.trim();\n            polygon.push(parseStrCoordinate(point));\n        });\n    }\n\n    // Donut polygon\n    else{\n        console.log(wktString);\n        console.log(\"Non-donut not yet supported!!\");\n    }\n\n    return polygon;\n}\n\nfunction parsePoint(wktString: string): number[]{\n    const point = wktString.split(\"(\")[1].split(\")\")[0].trim();  // Ex [\"0 0 0\"]\n    return parseStrCoordinate(point);\n}\n\nfunction parseStrCoordinate(strCoordinate: string): number[]{\n    return strCoordinate.split(\" \").map(p => parseFloat(p));\n}","var pointInPolygonFlat = require('./flat.js')\nvar pointInPolygonNested = require('./nested.js')\n\nmodule.exports = function pointInPolygon (point, vs, start, end) {\n    if (vs.length > 0 && Array.isArray(vs[0])) {\n        return pointInPolygonNested(point, vs, start, end);\n    } else {\n        return pointInPolygonFlat(point, vs, start, end);\n    }\n}\nmodule.exports.nested = pointInPolygonNested\nmodule.exports.flat = pointInPolygonFlat\n","module.exports = function pointInPolygonFlat (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = (end-start)/2;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];\n        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","// ray-casting algorithm based on\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\nmodule.exports = function pointInPolygonNested (point, vs, start, end) {\n    var x = point[0], y = point[1];\n    var inside = false;\n    if (start === undefined) start = 0;\n    if (end === undefined) end = vs.length;\n    var len = end - start;\n    for (var i = 0, j = len - 1; i < len; j = i++) {\n        var xi = vs[i+start][0], yi = vs[i+start][1];\n        var xj = vs[j+start][0], yj = vs[j+start][1];\n        var intersect = ((yi > y) !== (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n","import { DataFactory } from \"rdf-data-factory\";\nimport type * as RDF from '@rdfjs/types';\nimport { geometryType, parseWKT } from \"./wkt-parser\";\nimport pointInPolygon from \"point-in-polygon\";\n\nconst DF = new DataFactory();\n\nexport const geoSPARQLFunctions = {\n\n    // geosf:distance(p1, p2, decimals, multiplicationFactor)\n    'http://www.opengis.net/def/function/geosparql/distance'(args: RDF.Term[]) {\n        \n        // Set defaults\n        const decimals = args[2] != undefined ? parseFloat(args[2].value) : 8;\n        const mf = args[3] != undefined ? parseFloat(args[3].value) : 1;\n\n        if (args[0].termType === 'Literal' && args[1].termType === 'Literal') {\n            const p1 = parseWKT(args[0].value);\n            const p2 = parseWKT(args[1].value);\n\n            if(p1 && p2 && p1.value && p2.value){\n\n                const a = p1.value[0] - p2.value[0];\n                const b = p1.value[1] - p2.value[1];\n                let d: number;\n\n                // XY\n                if(p1.type == geometryType.POINT && p2.type == geometryType.POINT){\n                    d = Math.sqrt(a * a + b * b);\n                }\n\n                // XYZ\n                if(p1.type == geometryType.POINTZ && p2.type == geometryType.POINTZ){\n                    const c = p1.value[2] - p2.value[2]; // Get z- coordinates\n                    d = Math.sqrt(a * a + b * b + c * c);\n                }\n\n                // Apply multiplication factor and round\n                d = d * mf;\n                d = round(d, decimals);\n\n                return DF.literal(d.toString(), DF.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));\n                \n            }\n            \n        }\n        return DF.literal(\"ERROR\");\n        \n    },\n\n    // geosf:inside(point, polygon)\n    'http://www.opengis.net/def/function/geosparql/inside'(args: RDF.Term[]) {\n        const decimals = args[2] != undefined ? parseFloat(args[2].value) : 8;\n        if (args[0].termType === 'Literal' && args[1].termType === 'Literal') {\n            const point = parseWKT(args[0].value);\n            const polygon = parseWKT(args[1].value);\n\n            if(point && polygon && point.value && polygon.value.length){\n\n                if(polygon.type == geometryType.POLYGON){\n\n                    const pg = polygon.value;\n                    let p: number[] = point.value;\n\n                    if(point.type == geometryType.POINTZ){\n                        // Pop last item to make XY instead of XYZ\n                        p.pop();\n                    }\n                    \n                    const inside = pointInPolygon(p, pg);\n                    return DF.literal(inside.toString(), DF.namedNode('http://www.w3.org/2001/XMLSchema#boolean'));\n\n                }\n                \n            }\n            \n        }\n        return DF.literal(\"ERROR\");\n        \n    }\n\n}\n\nfunction round(num: number, decimals: number = 0): number{\n    return Math.round( num * (10 ** decimals) + Number.EPSILON ) / (10 ** decimals);\n}"],"names":["Object","defineProperty","BlankNode_1","value","constructor","this","termType","equals","other","DefaultGraph_1","DefaultGraph","INSTANCE","NamedNode_1","Literal_1","require$$0","Literal","languageOrDatatype","language","datatype","RDF_LANGUAGE_STRING","XSD_STRING","NamedNode","Quad_1","subject","predicate","object","graph","Variable_1","DataFactory_1","require$$1","require$$2","require$$3","require$$4","require$$5","dataFactoryCounter","__createBinding","__exportStar","geometryType","options","blankNodeCounter","blankNodePrefix","namedNode","blankNode","BlankNode","literal","variable","Variable","defaultGraph","quad","Quad","fromTerm","original","fromQuad","resetBlankNodeCounter","create","o","m","k","k2","undefined","enumerable","get","exports","p","prototype","hasOwnProperty","call","require$$6","typeMap","POINT","POINTZ","POLYGON","POLYGONZ","parseWKT","wktString","type","typeStr","toLocaleLowerCase","split","replace","keys","indexOf","UNKNOWN","getType","coordinates","parseStrCoordinate","trim","parsePoint","polygon","length","map","point","push","console","log","parsePolygon","strCoordinate","parseFloat","pointInPolygonFlat","vs","start","end","x","y","inside","len","i","j","xi","yi","xj","yj","pointInPolygonNested","pointInPolygonModule","Array","isArray","DF","DataFactory","geoSPARQLFunctions","args","decimals","mf","p1","p2","d","a","b","Math","sqrt","c","num","round","Number","EPSILON","toString","pg","pop","pointInPolygon"],"mappings":"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"}